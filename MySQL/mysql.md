# 一条SQL语句的执行过程

![](https://github.com/ZH1995/note/blob/main/MySQL/img/mysql_arch.png) 



**连接器**：与MySQL建立连接，用户鉴权。

**查询缓存**：开启后，以查询语句做key，查询缓存。由于表数据只要发生变更，就会触发缓存清除，建议关闭。

**分析器**：词法分析解析出表名、列名等；语法分析检查是否符合MySQL语法。

**优化器**：选择索引、连表顺序等最佳查询方案。

**执行器**：调用存储层具体存储引擎的读写接口，获取存储数据。


# Redo Log和Binlog

**redo log和binlog的区别**

1.redo log是InnoDB引擎特有的；binlog是MySQL的server层实现的，所有引擎都可以使用。

2.redo log是物理日志，记录的是"在某个数据页上做了什么修改"；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如"给id=2这一行的count字段加1"。

3.redo log是循环写入的，空间固定会用完；binlog是追加写入的，写到一定大小后会切换到下一个，不会覆盖以前的日志。

# Redo Log两阶段提交

**为什么要有两阶段提交**

Redo log具有crash-safe特性，在数据库发生异常重启后，之前提交的记录都不会丢失。如果没有两阶段提交，在数据库发生异常重启后，会造成redo log和binlog之间数据不一致。

**什么是两阶段提交**

引擎将数据更新到内存后，同时将数据更新到redo log里，此时redo log处于prepare状态。通知执行器执行完成了，随时可以提交事务。

执行器生成这个操作的binlog，并把binlog写入磁盘。

执行器调用引擎的提交事务接口，引擎把redo log状态改为commit状态，更新完成。

# 事务隔离

**事务特性**：原子性、一致性、隔离性、持久性。

**隔离级别**：

- 读未提交：一个事务还未提交时，它做的变更就能够被别的事务看到。
- 读已提交：一个事务提交后，它做的变更才能被别的事务看到。
- 可重复读：一个事务执行过程中，前后看到的数据保持一致。
- 串行化：对于同一行记录，写会加写锁，读加读锁。当出现读写冲突时，后访问的事务必须等前一个事务执行完成，才能继续执行。

#### 事务的启动方式

- 显示：start transaction或begin，提交commit，回滚rollback。
- 隐式：set autocommit=0，只要执行select就会启动事务。该事务不会自动提交，直到主动执行commit或rollback语句或断开连接。


# InnoDB索引

InnoDB使用了B+树索引模型，每个索引都有一颗对应的B+树。

**索引为什么用N叉树而不用二叉树模型**

N叉树能够降低树高，减少磁盘寻址开销。

**主键索引（聚簇索引）**

叶子节点存的是整行数据。

**非主键索引（二级索引）**

叶子节点存的是主键的值，查询到主键后再查询主键B+树，称为回表。

**如何避免回表**

1.覆盖索引，即二级索引的叶子节点数据满足查询结果，无需回表操作。

2.前缀索引，遵循最左前缀原则，建立联合索引。

3.索引下推，在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不满足的条件，减少回表次数。