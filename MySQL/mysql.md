# 一条SQL语句的执行过程

![](https://github.com/ZH1995/note/blob/main/MySQL/img/mysql_arch.png) 



**连接器**：与MySQL建立连接，用户鉴权。

**查询缓存**：开启后，以查询语句做key，查询缓存。由于表数据只要发生变更，就会触发缓存清除，建议关闭。

**分析器**：词法分析解析出表名、列名等；语法分析检查是否符合MySQL语法。

**优化器**：选择索引、连表顺序等最佳查询方案。

**执行器**：调用存储层具体存储引擎的读写接口，获取存储数据。


# Redo Log和Binlog

**redo log和binlog的区别**

1.redo log是InnoDB引擎特有的；binlog是MySQL的server层实现的，所有引擎都可以使用。

2.redo log是物理日志，记录的是"在某个数据页上做了什么修改"；binlog是逻辑日志，记录的是这个语句的原始逻辑，比如"给id=2这一行的count字段加1"。

3.redo log是循环写入的，空间固定会用完；binlog是追加写入的，写到一定大小后会切换到下一个，不会覆盖以前的日志。

# Redo Log两阶段提交

**为什么要有两阶段提交**

Redo log具有crash-safe特性，在数据库发生异常重启后，之前提交的记录都不会丢失。如果没有两阶段提交，在数据库发生异常重启后，会造成redo log和binlog之间数据不一致。

**什么是两阶段提交**

引擎将数据更新到内存后，同时将数据更新到redo log里，此时redo log处于prepare状态。通知执行器执行完成了，随时可以提交事务。

执行器生成这个操作的binlog，并把binlog写入磁盘。

执行器调用引擎的提交事务接口，引擎把redo log状态改为commit状态，更新完成。

# 事务隔离

**事务特性**：原子性、一致性、隔离性、持久性。

**隔离级别**：

- 读未提交：一个事务还未提交时，它做的变更就能够被别的事务看到。
- 读已提交：一个事务提交后，它做的变更才能被别的事务看到。
- 可重复读：一个事务执行过程中，前后看到的数据保持一致。
- 串行化：对于同一行记录，写会加写锁，读加读锁。当出现读写冲突时，后访问的事务必须等前一个事务执行完成，才能继续执行。

#### 事务的启动方式

- 显示：start transaction或begin，提交commit，回滚rollback。
- 隐式：set autocommit=0，只要执行select就会启动事务。该事务不会自动提交，直到主动执行commit或rollback语句或断开连接。


# InnoDB索引

InnoDB使用了B+树索引模型，每个索引都有一颗对应的B+树。

**索引为什么用N叉树而不用二叉树模型**

N叉树能够降低树高，减少磁盘寻址开销。

**主键索引（聚簇索引）**

叶子节点存的是整行数据。

**非主键索引（二级索引）**

叶子节点存的是主键的值，查询到主键后再查询主键B+树，称为回表。

**如何避免回表**

1.覆盖索引，即二级索引的叶子节点数据满足查询结果，无需回表操作。

2.前缀索引，遵循最左前缀原则，建立联合索引。

3.索引下推，在索引遍历过程中，对索引中包含的字段先做判断，过滤掉不满足的条件，减少回表次数。

# 全局锁

**FTWRL**（flush tables with read lock）：加全局读锁，这个数据库处于只读状态。

Single-transaction：适用于所有表都使用事务引擎的库。

# 表级锁

1.lock tables ... read/write给表加读/写锁，unlock tables主动释放锁。

2.MDL（metadata lock），在访问一个表时会被自动加上。读锁之间不互斥，读写锁之间、写锁之间互斥。

# 行锁

**两阶段锁**

扩展阶段：获得锁，但不释放。

收缩阶段：事务结束，释放锁。

**死锁**

并发系统中不同线程出现循环资源依赖，涉及的线程都在等待其他线程释放资源，导致这几个线程都陷入无限等待状态。

**解决死锁的方案**

1.直接进入等待，直到超时。默认超时时间50s，通常不采用。

2.发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以执行，默认开启。



## 优化器选错索引

**为什么优化器会选错索引**

优化器选择索引的目的是找到一个最优的执行方案，扫描行数是影响执行代价的因素之一，但是MySQL的扫描行数判断并不准确，它是通过采样来估算的。

**MySQL如何判断扫描行数**

默认选择N页，统计这些页面上的不同值，得到一个平均值，然后乘以这个索引的页面数，就得到了索引基数。

**如何处理优化器选错索引**

- 采用force index强行选择索引。
- 修改语句，引导MySQL使用我们期望的索引。
- 建立一个更合适的索引，删掉误用的索引。
- analyze table t命令重新统计索引信息，这个过程加了MDL读锁。





**InnoDB数据删除**

InnoDB的数据存储在一个以.idb为后追的文件中，增删改表只是把记录的位置或者数据页标记为"可复用"。并不会回收表空间，造成页分裂或者空洞。

**Online DDL**

1.建立一个临时文件，扫描表A主键的所有数据页。

2.用数据页中表A的记录生成B+树，存储到临时文件中。

3.生成临时文件的过程中，将所有对A的操作记录到一个日志文件中（row log）。

4.临时文件生成后，将日志文件中的操作应用于临时文件，得到一个逻辑数据上与表A相同的数据文件。

5.用临时文件替换表A的数据文件。



**MyISAM和InnoDB如何实现count(*)**

不考虑过滤条件的情况下：

MyISAM：把表的总行数存在磁盘上，执行时直接返回即可。

InnoDB：把数据逐行从引擎里读出来，然后累计积数。



**各种count效率**

count(字段) < count(主键id) < count(1) ≈ count(*)

count(1)遍历整张表，但不取值。server层对于返回的每一行，放一个数字"1"进去，判断是不可能为空的，按行累加。

count(主键id)遍历整张表后，把id取出来。server层对于返回的每一行，判断非空则累加。





# 全字段排序与rowid排序

InnoDB设计思想：如果在内存足够的情况下，优先选择全字段排序，因为执行全字段排序会减少磁盘访问。

**全字段排序**

1.初始化sort_buffer，确定放入的查询字段。

2.查询非主键索引的B+树，找到主键ID。

3.根据主键ID查询主键索引的B+树，**取查询字段**，放入sort_buffer。

4.从非主键索引中取下一个记录的主键ID。

5.重复3、4步直到非主键索引不满足条件为止。

6.对sort_buffer中的数据按照order by字段做快速排序。

7.取排序结果的前N行返回给客户端。

**rowid排序**

1.初始化sort_buffer，确定放入的排序字段、主键。

2.查询非主键索引的B+树，找到主键ID。

3.根据主键ID查询主键索引的B+树，**取排序字段、主键**，放入sort_buffer。

4.从非主键索引中取下一个记录的主键ID。

5.重复3、4步直到非主键索引不满足条件为止。

6.对sort_buffer中的数据按照排序字段做快速排序。

7.取前1000行，按照主键的值**到原表中取查询字段**返回给客户端。

**什么是rowid**

- 对于有主键的InnoDB表来说，rowid就是主键ID。
- 对于没有主键的InnoDB表来说，rowid是由系统自动生成的。



**binlog的写入机制**

每个线程先把日志写入自己的binlog cache中，积累了N个事务提交后，执行器把binlog cache里的事务写入同一个binlog中，调用fsync持久化，最后清空binlog cache。

**redo log的三种状态**

- 存在redo log buffer中，物理上在MySQL的内存中。
- 写到磁盘，但是没有持久化，物理上在文件系统的page cache里。
- 持久化到磁盘。

